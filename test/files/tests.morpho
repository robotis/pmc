mainModule =
!
{{
main =
	fun()
	{
		for(;;)
		{
			break null
		};
		try
		{
			main2();
		}
		catch(e)
		{
			printExceptionTrace(&e);
		};
	};

main2 =
	fun()
	{
		var allok=true;
		rec fun doTest(name,@t)
		{
			write(name++" test ");
			val start = nanoTime();
			val res = t;
			val dur = nanoTime()-start;
			if( res )
			{
				writeln("OK - "++(double(dur)/1.0E9));
			}
			else
			{
				writeln("failed - "++(double(dur)/1.0E9));
			};
			allok = res && allok;
		};

		;;; Patrick Kerr: 661 4561

		doTest("Channels 2"){testChannels2(1,1000000)};

		doTest("By name 1"){testByName0()};
		doTest("By name 2"){testByName1()};
		doTest("Channels 1"){testChannels1(1000,1000,1000)};
		;;;doTest("Channels 2"){testChannels2(10000,1000)};
		doTest("Channels 3"){testChannels3(1000000,100)};
		doTest("Streaming 1"){testStreaming1(fun(f){makePromise(f)},fun(x){force(x)})};
		doTest("Streaming 2"){testStreaming1(fun(f){myMakePromise(f)},fun(x){myForce(x)})};
		doTest("Streaming 3"){testStreaming2()};
		doTest("Locks"){testLocks(1000000)};
		doTest("Tail"){testTail()};
		doTest("Multiple assignment"){testMulti(100)};
		doTest("Lists 1"){testLists(10)};
		doTest("Lists 2"){testLists(100)};
		doTest("Lists 3"){testLists(100000)};
		doTest("Seq 1"){testSeq(100)};
		doTest("Seq 2"){testSeq(10000)};
		doTest("Object"){testObj()};
		doTest("Fibers 1"){testFibers1(10)};
		doTest("Fibers 1b"){testFibers1(10000)};
		;;;doTest("Fibers 1c"){testFibers1(9000000)};		;;; 8000000 OK with -Xmx1300, 113sec, 9000000 OK but very slow
		doTest("Fibers 2"){testFibers2(10)};
		doTest("Fibers 2b"){testFibers2(10000)};
		;;;doTest("Fibers 2c"){testFibers2(8000000)};		;;; 7000000 OK with -Xmx1300, 35sec, 8000000 80sec, 9000000 failed
		doTest("Fibers 3"){testFibers3(10000)};
		doTest("Exceptions"){testExceptions()};
		doTest("Task 1"){testTasks1(10)};
		doTest("Task 1"){testTasks1(100)};
		;;;doTest("Task 2"){testTasks1(3400000)};			;;; 3000000 OK with -Xmx1300, 3400000 OK 146sec, 3500000 failed
		doTest("Machines"){testMachines1(2000)};			;;; 3000 failed, 2000 OK with default stack size
		doTest("Not"){testNot()};
		doTest("Compose"){testCompose()};
		doTest("Global var 1"){testGlobalGlobals()};
		doTest("Task var 2"){testTaskGlobals()};
		doTest("Machine var 3"){testMachineGlobals()};
		doTest("Array"){testArrays()};
		doTest("Scope 1"){testScopes1()};
		doTest("Scope 2"){testScopes2()};
		doTest("Scope 3"){testScopes3()};
		doTest("Break 1"){testBreak1()};
		doTest("Break 2"){testBreak2()};
		doTest("Return"){testReturn()};
		doTest("Cond"){testCond()};
		doTest("Local function"){testLocalFun()};
		doTest("Recursive definitions"){testRecDef()};

		;;;doTest("Const test 1"){testConst1()};
		;;;doTest("Const test 2"){testConst2()};


		if( allok )
		{
			writeln("All tests passed");
		}
		else
		{
			writeln("Some tests failed");
		};

		exit(0);
	};

myMakePromise =
	fun(f)
	{
		makeMutex() : f;
	};

myForce =
	fun(p)
	{
		val lock = head(p);
		if( !lock ) {return tail(p)};
		acquireMutex(lock);
		if( !head(p) )
		{
			releaseMutex(lock);
			return tail(p);
		};
		setTail(p,tail(p)());
		setHead(p,null);
		releaseMutex(lock);
		tail(p);
	};

testByName0	=
	fun()
	{
		var x=true;
		var @y = makeThunk(fun(){x},fun(z){x=z});
		y = false;
		if( x ) {return false};
		y = true;
		if( !x ) {return false};
		getThunkSetter(@y)(!(getThunkGetter(@y)()));
		if( x ) {return false};
		testByNameHelp1(@x){true};
		testByNameHelp1(var x){false};
		x
	};

testByName1 =
	fun()
	{
		var x = false;
		rec fun help(@x,@y) {x=y};
		help(@x){true};
		if( !x ) {return false};
		x = false;
		testByNameHelp1(@x){true};
		testByNameHelp1(var x){null};
		testByNameHelp1(var x=false){null};
		testByNameHelp1(var x){x};
		{var x;testByNameHelp1(@x){false}};
		return x;
	};

testByNameHelp1 =
	fun(@x,@y)
	{
		val z = y;
		x = z;
	};

testNot =
	fun()
	{
		var x=true;
		if( x ) {} else {return false;};
		if( !x ) {return false;};
		if( ! ! !x ) {return false;};
		x = ! x;
		if( x ) {return false;};
		if( ! ! x ) {return false;};
		x = false;
		if( x ) {return false;};
		if( ! !x ) {return false;};
		x = ! x;
		if( ! x ) {return false;};
		if( ! ! ! x ) {return false;};
		x = 0;
		if( x ) {} else {return false;};
		if( !x ) {return false;};
		if( ! ! !x ) {return false;};
		x = ! x;
		if( x ) {return false;};
		if( ! ! x ) {return false;};
		x = 1;
		if( x ) {} else {return false;};
		if( !x ) {return false;};
		if( ! ! !x ) {return false;};
		x = ! x;
		if( x ) {return false;};
		if( ! ! x ) {return false;};
		x = "";
		if( x ) {} else {return false;};
		if( !x ) {return false;};
		if( ! ! !x ) {return false;};
		x = ! x;
		if( x ) {return false;};
		if( ! ! x ) {return false;};
		x = 'a';
		if( x ) {} else {return false;};
		if( !x ) {return false;};
		if( ! ! !x ) {return false;};
		x = ! x;
		if( x ) {return false;};
		if( ! ! x ) {return false;};
		x = null;
		if( x ) {return false;};
		if( ! !x ) {return false;};
		x = ! x;
		if( ! x ) {return false;};
		if( ! ! ! x ) {return false;};
		return true;
	};

testStringLiterals =
	fun()
	{
		var s;
		s = "\""; s[0] == '\"' || (return false);
		s = "\'"; s[0] == '\'' || (return false);
		s = "\\"; s[0] == '\\' || (return false);
		s = "\""; s[0] == '\"' || (return false);
		s = "\r"; s[0] == '\r' || (return false);
		s = "\15"; s[0] == '\r' || (return false);
		s = "\r"; s[0] == '\15' || (return false);
		s = "\n"; s[0] == '\n' || (return false);
		s = "\12"; s[0] == '\n' || (return false);
		s = "\n"; s[0] == '\12' || (return false);
		s = "\n"; s[0] == '\u000A' || (return false);
		s = "\n"; s[0] == '\u000a' || (return false);
		s = "\u000A"; s[0] == '\u000a' || (return false);
		s = "\f"; s[0] == '\f' || (return false);
		s = "\14"; s[0] == '\f' || (return false);
		s = "\f"; s[0] == '\14' || (return false);
		s = "\b"; s[0] == '\b' || (return false);
		s = "\10"; s[0] == '\b' || (return false);
		s = "\b"; s[0] == '\10' || (return false);
		s = "\b"; s[0] == '\u0008' || (return false);
		s = "\t"; s[0] == '\t' || (return false);
		s = "\11"; s[0] == '\t' || (return false);
		s = "\t"; s[0] == '\11' || (return false);
		s = "\t"; s[0] == '\u0009' || (return false);
		s = "\0"; s[0] == '\0' || (return false);
		s = "\7"; s[0] == '\7' || (return false);
		s = "\07"; s[0] == '\07' || (return false);
		s = "\77"; s[0] == '\77' || (return false);
		s = "\077"; s[0] == '\077' || (return false);
		s = "\377"; s[0] == '\377' || (return false);
		s = "\101"; s[0] == 'A' || (return false);
		s = "A"; s[0] == '\101' || (return false);
		return true;
	};

testTail =
	fun()
	{
		tail1() || writeln("tail1 failed");
		tail2() || writeln("tail2 failed");
		tail3() || writeln("tail3 failed");
		tail4() || writeln("tail4 failed");
	};

tail1 =
	fun()
	{
		var m=makeArray(10);
		m[0] = fun(){true;};
		m = m[0];
		m();
	};

tail2 =
	fun()
	{
		var m=fun(){fun(){true;};};
		m = m();
		m();
	};

tail3 =
	fun()
	{
		var m=makeArray(10);
		m[0] = fun(){true;};
		m[0]();
	};

tail4 =
	fun()
	{
		var m=fun(){fun(){true;};};
		m()();
	};

testRecDef =
	fun()
	{
;;;		rec
;;;			val a,b,a=#[1$b],b=#[2$a],
;;;			fun f(n){g(n);},
;;;			fun h(n){f(n);},
;;;			fun g(n){n;},
;;;			var x,y=#[3$x],x=y;
;;;		if( streamHead(a)!=1 ) {return false;}:
;;;		if( streamHead(b)!=2 ) {return false;}:
;;;		if( streamHead(streamTail(a))!=2 ) {return false;}:
;;;		if( streamHead(streamTail(b))!=1 ) {return false;}:
;;;		if( streamHead(x)!=3 ) {return false;}:
;;;		if( streamHead(y)!=3 ) {return false;}:
;;;		if( streamHead(streamTail(x))!=3 ) {return false;}:
;;;		if( streamHead(streamTail(y))!=3 ) {return false;}:
;;;		if( f(10) != 10 ) {return false;};
;;;		if( g(10) != 10 ) {return false;};
;;;		if( h(10) != 10 ) {return false;};
		return true;
	};

testLocalFun =
	fun()
	{
		var x=0;
		val z=$x;
		var x=1,y;
		val y=0;
		rec
			fun +(x,y) {x-y;},
			fun +(x) {0-x;},
			fun !!(x) {if( !x ) {return 0;}; inc(!!tail(x));};
		val len = fun(x) {return 0;};
		rec fun len(x) {if( !x ) {return 0;}; inc(len(tail(x)));};
		val minus = fun -(x,y);
		val m = fun(x,y){minus(x,y);};
		var ok = true;
		ok = ok && (2+1==1);
		ok = ok && (+10 == (0-10));
		ok = ok && (len([1,2,3])==3);
		ok = ok && !![1,2,3] == 3;
		ok = ok && minus(2,1)==1;
		ok = ok && m(2,1)==1;
		ok = ok && fun+(x,y)(2,1)==3;
	};

testObj =
	fun()
	{
		val s1 = stack1(), s2 = stack2([]);
		val test =
			fun(s)
			{
				var i;
				for( i=0 ; i!=100 ; i=inc(i) )
				{
					s.push(i);
					s.top() == i || (return false);
				};
				!s.isEmpty() || (return false);
				for( i=0 ; i!=100 ; i=inc(i) )
				{
					s.pop()+i == 99 || (return false);
				};
				s.isEmpty() || (return false);
				true;
			};
		test(s1) && test(s2);
	};

stack1 =
	obj()
	{
	var list=[];
	msg push(x)
		{
			list = x:list;
			[];
		};
	msg pop()
		{
			this.innerPop();
		};
	msg innerPop()
		{
			val g = head(list);
			list = tail(list);
			g;
		};
	msg top()
		{
			head(list);
		};
	msg isEmpty()
		{
			list==[];
		};
	};

stack2 =
	obj(list_in)
	{
	var list = list_in;
	msg push(x)
		{
			list = x:list;
			[];
		};
	msg pop()
		{
			this.innerPop();
		};
	msg innerPop()
		{
			val g = head(list);
			list = tail(list);
			g;
		};
	msg top()
		{
			head(list);
		};
	msg isEmpty()
		{
			list==[];
		};
	};

testSeq =
	fun(n)
	{
		var sum=0, nums, sum2=0;

		nums =
			seq
			{
				x #<<= fromUpTo(1,n);
				sum = sum+x;
				#[x];
			};
		sum == 1 || (return false);

		while( nums != #[] )
		{
			sum2 = sum2+streamHead(nums);
			nums = streamTail(nums);
		};

		if( sum != n*(n+1)/2 || sum2!=sum )
		{
			writeln("B");
			return false;
		};

		nums =
			seq
			{
				x #<<= fromUpTo(1,n);
				sum = sum+x;
				[];
			};
		nums == [] || (return false);

		sum = 0;
		;;;writeln(
			streamToList(
				seq
				{
					x #<<= fromUpTo(0,5);
					sum = sum+x;
					y #<<= fromUpTo(0,x);
					#[[x,y]];
				}
			);;; )
		;
		sum==(1+2+3+4+5);

	};

testMulti =
	fun(n)
	{
		val fibo1 =
			fun(n)
			{
				var f1=1,f2=1,i;
				for( i=1 ; i!=n ; i=i+1 )
				{
					var tmp=f1+f2;
					f1=f2;
					f2=tmp;
				};
				f1;
			};
		var fibo2 =
			fun(n)
			{
				var f1=1,f2=1,i=1;
				while( i!=n )
				{
					(i,f1,f2)=(i+1,f2,f1+f2);
				};
				f1;
			};
		fibo1(n)==fibo2(n);
	};

testFibers1 =
	fun(n)
	{
		var i,sum=long(0), main, arr=makeArray(n);
		var f =
			fun(n)
			{
				sum = sum+n;
				transfer(null,main,null);
			};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			arr[i] = makeFiber(f,i);
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			transfer(&main,arr[i],null);
		};
		sum==long(n)*(n-1)/2;
	};

testFibers2 =
	fun(n)
	{
		var i,sum=long(0),count=n;
		rec fun f(n)
		{
			sum = sum+n;
			count = count-1;
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			var x=i;
			goFiber{f(x)};
		};
		i = 0;
		while( count!=0 )
		{
			i = inc(i);
			yieldFiber();
		};
		writeln("Yielded "++i++" times");
		sum==long(n)*(n-1)/2;
	};

testFibers3 =
	fun(n)
	{
		var i,sum=long(0),count=n,c=makeBufferedChannel(10);
		rec fun f(n)
		{
			for( var i=0 ; i!=n ; i=inc(i) )
			{
				c <- i;
			};
			closeChannel(c);
		};
		goFiber{f(n)};
		i = <- c;
		while( i!=channelEOF() )
		{
			sum = sum+i;
			i = <- c;
		};
		sum==long(n)*(n-1)/2;
	};

testTasks1 =
	fun(n)
	{
		var i,
			sum = long(0),
			count = n,
			c = makeChannel();
		for( i=0 ; i!=n ; i=inc(i) )
		{
			val x = i;
			goTask{c <- x};
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			sum = sum + <-c;
		};
		sum==long(n)*(n-1)/2;
	};

testMachines1 =
	fun(n)
	{
		var i,sum=long(0),count=n,c=makeChannel();
		for( i=0 ; i!=n ; i=inc(i) )
		{
			val x = i;
			goMachine(1){c <- x};
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			sum = sum + <-c;
		};
		sum==long(n)*(n-1)/2;
	};

testChannels1 =
	fun(n,m,k)
	{
		var i, sum = 0;
		val mutex = makeMutex();
		val c = makeChannel();
		val change = makeChannel();
		rec fun add(x)
		{
			acquireMutex(mutex);
			sum = sum+x;
			releaseMutex(mutex);
			change <- "change";
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			goTask
			{
				for( var i=0 ; i!=k ; i=inc(i) ) {c<-1}
			};
		};
		for( i=0 ; i!=m ; i=inc(i) )
		{
			goTask
			{
				for(;;)
				{
					add(<-c)
				}
			};
		};
		val nn = n*k;
		for( i=0 ; i!=nn ; i=inc(i) )
		{
			<- change
		};
		sleep(1.0);
		sum==nn;
	};

testChannels2 =
	fun(m,k)
	{
		var i, sum = 0;
		val s = makeChannelSelector();
		val start = nanoTime();
		for( i=0 ; i!=m ; i=inc(i) )
		{
			val c = makeChannel();
			s.addReadSubscription(c);
			goTask
			{
				try
				{
					for( var i=0 ; i!=k ; i=inc(i) ) {c<-i};
					c <- channelEOF();
				}
				catch(e)
				{
					printExceptionTrace(&e);
				}
			}
		};
		val cc = s.start();
		val n = m*k;
		for( i=0 ; i!=n ; i=inc(i) )
		{
			val x = <- <- cc;
			if( x!=i ) {throw "Fail"};
			sum = sum + 1;
		};
		if( sum!=n ) {return false};
		write("(With multiplexor: "++long((double(n)*1.0e9/double(nanoTime()-start)))++" messages per second) ");
		;;;goFiber{sum = sum + <- <- cc};
		sleep(1.0);
		sum==n;
	};

testChannels3 =
	fun(n,m)
	{
		val c = makeBufferedChannel(m);
		val start = nanoTime();
		goTask
		{
			for( var i=0 ; i!=n ; i=inc(i) )
			{
				c <- i;
			};
			c <- channelEOF();
		};
		var x = <- c;
		var sum = long(0);
		var i=0;
		while( x!=channelEOF() )
		{
			if( x!=i ) {return false};
			i = inc(i);
			sum = sum+x;
			x  = <- c;
		};
		write("(With buffering: "++long((double(n)*1.0e9/double(nanoTime()-start)))++" messages per second) ");
		sum==long(n-1)*n/2;
	};

testLocks =
	fun(n)
	{
		val infoLock = makeMutex();
		val doneChannel = makeChannel();
		var i=0;
		val arr = makeArray(n);

		rec fun filler()
		{
			for(;;)
			{
				acquireMutex(infoLock);
				var j=i;
				if( j==n )
				{
					releaseMutex(infoLock);
					doneChannel <- "done";
					return null;
				};
				val delayed = i+10;
				sleep(10000);
				i = delayed;
				releaseMutex(infoLock);
				sleep(10000);
				var k;
				for( k=0 ; k!=10 ; k=inc(k) )
				{
					arr[j+k] = j+k;
				};
			};
		};
		var k;
		for( k=0 ; k!=10000 ; k=inc(k) )
		{
			goTask{filler()};
		};
		for( k=0 ; k!=10000 ; k=inc(k) )
		{
			<- doneChannel;
		};
		for( k=0 ; k!=n ; k=inc(k) )
		{
			if( arr[k]!=k ) {return false};
		};
		return true;
	};

testStreaming1 =
	fun(make,force)
	{
		rec fun map(f,s)
		{
			f(head(s)) : make(fun(){map(f,force(tail(s)))});
		};
		var ints;
		var i;
		for( i=0 ; i!=1000000 ; i=inc(i) )
		{
			ints = 0 : make(fun(){map(fun(x){inc(x)},ints)});
		};
		for( i=0 ; i!=1000000 ; i=inc(i) )
		{
			if( head(ints)!=i ) {return false};
			ints = force(tail(ints));
		};
		return true;
	};

testStreaming2 =
	fun()
	{
		rec fun map(f,s)
		{
			#[ f(head(s)) $ map(f,streamTail(s)) ];
		};
		var ints;
		var i;
		for( i=0 ; i!=1000000 ; i=inc(i) )
		{
			ints = #[0 $ map(fun(x){inc(x)},ints) ];
		};
		for( i=0 ; i!=1000000 ; i=inc(i) )
		{
			if( streamHead(ints)!=i ) {return false};
			ints = streamTail(ints);
		};
		return true;
	};

testLists =
	fun(n)
	{
		var sum =
			fun(inx)
			{
				var n=0, x=inx;
				while( isPair(x) )
				{
					n = n+head(x);
					x = tail(x);
				};
				n;
			};
		var i=
			fun(n)
			{
				var j,res;
				for(j=0 ; j<=n ; j=inc(j))
				{
					res = j:res;
				};
				res;
			};
		[]==null || (return false);
		sum(i(n))==n*(n+1)/2 || (return false);
		n = [1,2,3,4,5,6];
		sum(n)==sum(i(6)) || (return false);
		setHead(n,0);
		sum(n)==sum(i(6))-1 || (return false);
		setTail(n,[10]);
		sum(n)==10 || (return false);
		true;
	};

;;; Testing function renaming in iteration:

testArrays = fun unusedFunctionName();

unusedFunctionName =
	fun()
	{
		var a,i,n=1000;

		a=makeArray(n);
		if( !isArray(a) )
		{
			return false;
		};
		if( isHashMap(a) )
		{
			return false;
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			a[i] = ("i="++i);
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			if( a[i] != "i="++i )
			{
				return false;
			};
		};

		if( arrayLength(a) != n )
		{
			return false;
		};

		a=makeHashMap();
		if( isArray(a) )
		{
			return false;
		};
		if( !isHashMap(a) )
		{
			return false;
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			a[""++i] = i+1;
		};
		for( i=0 ; i!=n ; i=inc(i) )
		{
			if( a[""++i] != i+1 )
			{
				return false;
			};
		};

		true;
	};

testReturn =
	fun()
	{
		var i=0;
		var f1 =
			fun()
			{
				"xyz";
			};
		var f2 =
			fun()
			{
				"xyz";
			};
		var f3 =
			fun()
			{
				return "xyz";
			};
		var f4 =
			fun()
			{
				return "xyz";
			};
		var f5 =
			fun()
			{
				return "xyz";
				"";
			};
		var f6 =
			fun()
			{
				return "xyz";
				"";
			};
		var f7 =
			fun()
			{
				{"xyz";};
			};
		var f8 =
			fun()
			{
				{"xyz";};
			};
		var f9 =
			fun()
			{
				{var z;"x"++(return "xyz");};
				"";
			};
		var f10 =
			fun()
			{
				{var z;return "xyz";};
				"";
			};
		var f11 =
			fun()
			{
				{var z;"x"++(return "xyz");};
				"";
			};
		var f12 =
			fun()
			{
				{var z;return "xyz";};
				"";
			};
		i = inc(i);
		if( f1()!="xyz" ) { return false; };
		i = inc(i);
		if( f2()!="xyz" ) { return false; };
		i = inc(i);
		if( f3()!="xyz" ) { return false; };
		i = inc(i);
		if( f4()!="xyz" ) { return false; };
		i = inc(i);
		if( f5()!="xyz" ) { return false; };
		i = inc(i);
		if( f6()!="xyz" ) { return false; };
		i = inc(i);
		if( f7()!="xyz" ) { return false; };
		i = inc(i);
		if( f8()!="xyz" ) { return false; };
		i = inc(i);
		if( f9()!="xyz" ) { return false; };
		i = inc(i);
		if( f10()!="xyz" ) { return false; };
		i = inc(i);
		if( f11()!="xyz" ) { return false; };
		i = inc(i);
		if( f12()!="xyz" ) { return false; };
		i = inc(i);
		if( fun(){"xyz";}()!="xyz" ) { return false; };
		i = inc(i);
		if( force($"xyz")!="xyz" ) { return false; };
		i = inc(i);
		return i==15;
	};

testScopes1 =
	fun()
	{
		var x = "X";
		{
			var y = "Y";
			var f =
				fun()
				{
					var z = "Z";
					x++y++z;
				};
			if( f()=="XYZ" )
			{
				return true;
				false;
			}
			else
			{
				return false;
				writeln("This can't happen A");
			};
			writeln("This can't happen B");
			false;
		};
		writeln("This can't happen C");
		false;
	};

testScopes2 =
	fun()
	{
		var i=1, f1=1, f2=1;
		while( i!=20 )
		{
			var tmp = f1+f2;
			i = i+1;
			f1 = f2;
			f2 = tmp;
			id(i); ;;; This used to fail
		};
		return f1==6765;
	};

id =
	fun(x)
	{
		x;
	};

testScopes3 =
	fun()
	{
		var i,a=makeHashMap();
		for( i=0 ; i!=10 ; i=inc(i) )
		{
			var x=i;
			a[i] = fun(){x;};
		};
		if( a[5]()==5 ) {writeln("Nested scope 1");};
		if( a[5]()==9 ) {writeln("Nested scope 2");};
		return (a[5]()==5) || (a[5]()==9);
	};

testBreak1 =
	fun()
	{
		var i;
		i = 
			for( i=0 ; i!=10 ; i=inc(i) )
			{
				var x=inc(i);
				if( i==5 ) {break x;};
				continue;
				throw "Continue failed";
			};
		return i==6;
	};

testBreak2 =
	fun()
	{
		var i=0;
		i =
			while( i!=10 )
			{
				var x=inc(i);
				if( i==5 ) {break x;};
				i = inc(i);
				continue;
				throw "Continue failed";
			};
		return i==6;
	};

{;;;
testConst1 =
	fun()
	{
		fibervar constCount1;
		constCount1 = 0;
		var i;
		for( i=0 ; i!=100 ; i=inc(i) )
		{
			const 1+2+(constCount1=inc(constCount1))+4;
		};
		return constCount1==1;
	};

testConst2 =
	fun()
	{
		fibervar constCount2;
		constCount2 = 1;
		var i;
		for( i=0 ; i!=100 ; i=inc(i) )
		{
			const 1+2+(constCount2=inc(constCount2))+4;
		};
		return constCount2==2;
	};
;;;}

testCond =
	fun()
	{
		var t=true, f=false, x;
		;;; Test short-circuit conditions
		if( f )
		{
			writeln("A");
			return false;
		};
		if( ! !f )
		{
			writeln("B");
			return false;
		};
		if( !t )
		{
			writeln("C");
			return false;
		};
		if( ! ! !t )
		{
			writeln("D");
			return false;
		};
		if( t && f )
		{
			writeln("E");
			return false;
		};
		if( ! ! ( t && f ) )
		{
			writeln("F");
			return false;
		};
		if( !(t || f) )
		{
			writeln("G");
			return false;
		};
		if( ! ! !(t || f) )
		{
			writeln("H");
			return false;
		};
		if( f && f )
		{
			writeln("I");
			return false;
		};
		if( f || f )
		{
			writeln("J");
			return false;
		};
		if( ! (t && t) )
		{
			writeln("K");
			return false;
		};
		if( ! ! (f && f) )
		{
			writeln("L");
			return false;
		};
		if( ! ! (f || f) )
		{
			writeln("M");
			return false;
		};

		;;; Test become
		if( force($f) )
		{
			writeln("N");
			return false;
		};
		if( force($(! !f)) )
		{
			writeln("O");
			return false;
		};
		if( force($(!t)) )
		{
			writeln("P");
			return false;
		};
		if( force($(! ! !t)) )
		{
			writeln("Q");
			return false;
		};
		if( force($(t && f)) )
		{
			writeln("R");
			return false;
		};
		if( force($(! ! ( t && f ))) )
		{
			writeln("S");
			return false;
		};
		if( force($(!(t || f))) )
		{
			writeln("T");
			return false;
		};
		if( force($(! ! !(t || f))) )
		{
			writeln("U");
			return false;
		};
		if( force($(f && f)) )
		{
			writeln("V");
			return false;
		};
		if( force($(f || f)) )
		{
			writeln("W");
			return false;
		};
		if( force($(! (t && t))) )
		{
			writeln("X");
			return false;
		};
		if( force($(! ! (f && f))) )
		{
			writeln("Y");
			return false;
		};
		if( force($(! ! (f || f))) )
		{
			writeln("Z");
			return false;
		};

		;;; Test expressions
		if( {var x=f;x;} )
		{
			writeln("�");
			return false;
		};
		if( {var x= ! !f;x;} )
		{
			writeln("�");
			return false;
		};
		if( {var x= !t;x;} )
		{
			writeln("�");
			return false;
		};
		if( {var x= ! ! !t;x;} )
		{
			writeln("a");
			return false;
		};
		if( {var x= t && f;x;} )
		{
			writeln("b");
			return false;
		};
		if( {var x= ! ! ( t && f );x;} )
		{
			return false;
		};
		if( {var x= !(t || f);x;} )
		{
			return false;
		};
		if( {var x= ! ! !(t || f);x;} )
		{
			return false;
		};
		if( {var x=f && f;x;} )
		{
			return false;
		};
		if( {var x=f || f;x;} )
		{
			return false;
		};
		if( {var x= ! (t && t);x;} )
		{
			return false;
		};
		if( {var x= ! ! (f && f);x;} )
		{
			return false;
		};
		if( {var x= ! ! (f || f);x;} )
		{
			return false;
		};

		x = false;
		t && {x=true;true;} || {x=false;};
		x || (return false);
		x = false;
		f && {x=false;true;} || {x=true;false;};
		x || (return false);

		t && f && (return false);
		(t && f || t) || (return false);
		t || (return false);
		!f || (return false);
		{ {x=false; x||t;} && {x=true;} && x || (return false);} || (return false);
		x || (return false);

		1==2 && (x=1) || (x=2);
		x==2 || (return false);

		1==2 || (x=3);
		x==3 || (return false);

		1==1 && (x=4);
		x==4 || (return false);
		try
		{
			if( 1 )
			{
				x=5;
			};
		}
		catch(e)
		{
			x=50;
		};
		x==5 || (return false);

		try
		{
			if( !1 )
			{
				x = 60;
			}
			else
			{
				x = 6;
			};
		}
		catch(e)
		{
			x=61;
		};
		x==6 || (return false);

		try
		{
			if( true && 1 )
			{
				x = 7;
			};
		}
		catch(e)
		{
			x=70;
		};
		x==7 || (return false);

		try
		{
			if( false || 1 )
			{
				x = 8;
			};
		}
		catch(e)
		{
			x=80;
		};
		x==8 || (return false);

		true;
	};

testGlobalGlobals =
	fun()
	{
		globalvar globalX, globalY, globalZ;
		if( globalX != null )
		{
			write("Global fail 1: "); writeln(globalX);
			return false;
		};
		globalX = "ABC";
		globalZ = "DEF";
		if( globalX != "ABC" )
		{
			write("Global fail 2: "); writeln(globalX);
			return false;
		};
		if( globalY != "ABC" )
		{
			write("Global fail 3: "); writeln(globalY);
			return false;
		};
		if( globalZ != "DEF" )
		{
			write("Global fail 4: "); writeln(globalZ);
			return false;
		};
		testGlobalGlobals2();
		if( globalX != 2 )
		{
			write("Global fail 5: "); writeln(globalX);
			return false;
		};
		if( globalY != 2 )
		{
			write("Global fail 6: "); writeln(globalY);
			return false;
		};
		if( globalZ != 3 )
		{
			write("Global fail 7: "); writeln(globalZ);
			return false;
		};

		true;
	};

testGlobalGlobals2 =
	fun()
	{
		globalvar globalX, globalY, globalZ;
		globalX=1;
		globalY=2;
		globalZ=3;
	};

testTaskGlobals =
	fun()
	{
		taskvar globalX, globalY, globalZ;
		if( globalX != null )
		{
			write("Global fail 1: "); writeln(globalX);
			return false;
		};
		globalX = "ABC";
		globalZ = "DEF";
		if( globalX != "ABC" )
		{
			write("Global fail 2: "); writeln(globalX);
			return false;
		};
		if( globalY != "ABC" )
		{
			write("Global fail 3: ");
			writeln(globalX++" "++globalY++" "++globalZ);
			return false;
		};
		if( globalZ != "DEF" )
		{
			write("Global fail 4: "); writeln(globalZ);
			return false;
		};
		testTaskGlobals2();
		if( globalX != 2 )
		{
			write("Global fail 5: "); writeln(globalX);
			return false;
		};
		if( globalY != 2 )
		{
			write("Global fail 6: "); writeln(globalY);
			return false;
		};
		if( globalZ != 3 )
		{
			write("Global fail 7: "); writeln(globalZ);
			return false;
		};

		true;
	};

testTaskGlobals2 =
	fun()
	{
		taskvar globalX, globalY, globalZ;
		globalX=1;
		globalY=2;
		globalZ=3;
	};

testMachineGlobals =
	fun()
	{
		machinevar globalX, globalY, globalZ;
		if( globalX != null )
		{
			write("Global fail 1: "); writeln(globalX);
			return false;
		};
		globalX = "ABC";
		globalZ = "DEF";
		if( globalX != "ABC" )
		{
			write("Global fail 2: "); writeln(globalX);
			return false;
		};
		if( globalY != "ABC" )
		{
			write("Global fail 3: "); writeln(globalY);
			return false;
		};
		if( globalZ != "DEF" )
		{
			write("Global fail 4: "); writeln(globalZ);
			return false;
		};
		testMachineGlobals2();
		if( globalX != 2 )
		{
			write("Global fail 5: "); writeln(globalX);
			return false;
		};
		if( globalY != 2 )
		{
			write("Global fail 6: "); writeln(globalY);
			return false;
		};
		if( globalZ != 3 )
		{
			write("Global fail 7: "); writeln(globalZ);
			return false;
		};

		true;
	};

testMachineGlobals2 =
	fun()
	{
		machinevar globalX, globalY, globalZ;
		globalX=1;
		globalY=2;
		globalZ=3;
	};

testCompose =
	fun()
	{
		testCompose2();
	};
}}
*
{{
;;; Testing variable renaming:
globalX = globalvar globalY;
globalX = taskvar globalY;
globalX = machinevar globalY;
}}
*
{{
;;; Testing variable finalizing
globalY = globalvar final;
globalY = taskvar final;
globalY = machinevar final;
}}
*
{{
;;; Should have no effect because of previous finalizing:
globalY = globalvar globalZ;
globalY = taskvar globalZ;
globalY = machinevar globalZ;
}}
*
{{
testCompose2 =
	fun()
	{
		testCompose();
	};
}}
*
(
;;; Testing compose
(
{{
testCompose = fun testComposex();
}}
:
{{
testComposex =
	fun()
	{
		if( f1() != "f3" )
		{
			write("Compose fail 1: "); writeln(f1());
			return false;
		};

		if( f2() != "f2" )
		{
			write("Compose fail 2: "); writeln(f2());
			return false;
		};

		true;
	};
}}
)
*
(
{{
f1 =
	fun()
	{
		f3();
	};
}}
:
{{
f2 =
	fun()
	{
		"f2";
	};
f3 =
	fun()
	{
		"f3";
	};
}}
)
)
*
!
{{
testExceptions =
	fun()
	{
		testAdvancedExceptions1() || (return false);
		testAdvancedExceptions2() || (return false);
		testAdvancedExceptions3() || (return false);
		testAdvancedExceptions4() || (return false);
		true;
	};

testAdvancedExceptions1 =
	fun()
	{
		var x="X",y="Y",z="Z",ex="ex";

		try
		{
			x = "X2";
			throw "Ball";
			y = "Y2";
		}
		catch( ex )
		{
			;;;printExceptionTrace(&ex);
			z = ex;
		};
		(x=="X2") && (y=="Y") && (z=="Ball") && (ex=="ex")
	};

testAdvancedExceptions2 =
	fun()
	{
		var x="X",y="Y",z="Z";

		try
		{
			x = "X2";
			1/0;
			y = "Y2";
		}
		catch( e )
		{
			;;;printExceptionTrace(&e);
			z = "Ball";
		};

		(x=="X2") && (y=="Y") && (z=="Ball") || (return false);

		z = "Z2";
		try
		{
			x = "X3";
			y = "Y2";
		}
		catch( e )
		{
			z = "Ball";
		};

		(x=="X3") && (y=="Y2") && (z=="Z2") || (return false);

		return true;
	};

testAdvancedExceptions3 =
	fun()
	{
		var x="X",y="Y",z="Z";

		fun() {
			try
			{
				x = "X2";
				1/0;
				y = "Y2";
			}
			catch( e )
			{
				z = "Ball";
			}
		}();

		(x=="X2") && (y=="Y") && (z=="Ball") || (return false);

		z = "Z2";
		fun()
		{
			try
			{
				x = "X3";
				y = "Y2";
			}
			catch( e )
			{
				z = "Ball";
			}
		}();

		(x=="X3") && (y=="Y2") && (z=="Z2") || (return false);

		return true;
	};

testAdvancedExceptions4 =
	fun()
	{
		var x="X",y="Y",z="Z";

		try
		{
			fun() {
				x = "X2";
				var a=1, b=0;
				a/b;
				y = "Y2";
			}();
		}
		catch( e )
		{
			;;;printExceptionTrace(&e);
			z = "Ball";
		};

		(x=="X2") && (y=="Y") && (z=="Ball") || (return false);
		z = "Z2";
		try
		{
			fun()
			{
				x = "X3";
				y = "Y2";
			}();
		}
		catch( e )
		{
			z = "Ball";
		};

		(x=="X3") && (y=="Y2") && (z=="Z2") || (return false);

		return true;
	};
}}
;

"tests.mmod" = mainModule;

"tests.mexe" = main in "tests.mmod" * BASIS;
