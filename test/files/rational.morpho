"rational.mmod" =
!
{{
makeRational =
	fun(a,b)
	{
		a = bigInteger(a);
		b = bigInteger(b);
		val z=coeffZero(), o=coeffOne();
		if( b<z ) { b = -b; a = -a };
		if( b==z ) { return if( a==z ) {[z$z]} else {[o$z]} };
		var d = gcd(a,b);
		if( a==z ) { return [z$o] };
		[a/d$b/d]
	};

numerator = fun head(x);

denominator = fun tail(x);

+++ =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val d = gcd(dx,dy);
		makeRational(nx*(dy/d)+ny*(dx/d),dy*(dx/d))
	};

*** =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val d1 = gcd(nx,dy),
			d2 = gcd(dx,ny);
		makeRational((nx/d1)*(ny/d2),(dy/d1)*(dx/d2))
	};

/// =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val d1 = gcd(nx,ny),
			d2 = gcd(dx,dy);
		makeRational((nx/d1)*(dy/d2),(dx/d2)*(ny/d1))
	};

--- =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val d = gcd(dx,dy);
		makeRational(nx*(dy/d)-ny*(dx/d),dy*(dx/d))
	};

=== =
	fun(x,y)
	{
		denominator(x)==denominator(y) &&
		numerator(x)==numerator(y)
	};

!=!=!= =
	fun(x,y)
	{
		denominator(x)!=denominator(y) &&
		numerator(x)!=numerator(y)
	};

<=<=<= =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val dd = gcd(dx,dy),
			dn = gcd(nx,ny);
		(nx/dn)*(dy/dd) <= (ny/dn)*(dx/dd)		
	};

>=>=>= =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val dd = gcd(dx,dy),
			dn = gcd(nx,ny);
		(nx/dn)*(dy/dd) >= (ny/dn)*(dx/dd)		
	};

<<< =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val dd = gcd(dx,dy),
			dn = gcd(nx,ny);
		(nx/dn)*(dy/dd) < (ny/dn)*(dx/dd)		
	};

>>> =
	fun(x,y)
	{
		val dx = denominator(x),
			dy = denominator(y),
			nx = numerator(x),
			ny = numerator(y);
		val dd = gcd(dx,dy),
			dn = gcd(nx,ny);
		(nx/dn)*(dy/dd) > (ny/dn)*(dx/dd)		
	};

show =
	fun(x)
	{
		val n = numerator(x), d = denominator(x);
		if( n==coeffZero() )
		{
			return if( d==coeffZero() ) {"NaN"} else {"0"};
		};
		if( d==coeffOne() ) { return showCoeff(n) };
		showCoeff(n)++"/"++showCoeff(d)
	};

zero =
	fun()
	{
		[coeffZero()$coeffOne()]
	};

one =
	fun()
	{
		[coeffOne()$coeffOne()]
	};
}}
*
!
{{
zero =
	fun()
	{
		0
	};
one =
	fun()
	{
		1
	};
show =
	fun(x)
	{
		""++x;
	};
gcd =
	fun(x,y)
	{
		if( x<0 ) {return gcd(-x,y)};
		if( y<0 ) {return gcd(x,-y)};
		if( x<y ) {return gcd(y,x)};
		if( y==0 ) {return x};
		return gcd(y,x%y);
	};
}}
;

"rationaltest.mexe" = main in
{{
main =
	fun()
	{
		var x = makeRational(1,2);
		var y = makeRational(1,3);
		writeln(show(x+++y));
	};
}}
*
"rational.mmod"
*
{{
coeffZero = fun() {0};
coeffOne = fun() {1};
showCoeff = fun(x) {""++x};
coeffZero = fun() {0};
}}
*
BASIS
;
